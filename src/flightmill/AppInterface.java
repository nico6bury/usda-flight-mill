/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JFrame.java to edit this template
 */
package flightmill;

import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
// import java.nio.file.attribute.FileTime;
// import java.time.LocalDateTime;
// import java.time.ZoneId;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.swing.JFileChooser;
import javax.swing.JOptionPane;

import com.formdev.flatlaf.*;

import flightmill.dataStorageStructs.FinalDataLine;
import flightmill.dataStorageStructs.InputCommandLine;
import flightmill.dataStorageStructs.InputDataLine;
import flightmill.dataStorageStructs.IntermediateDataLine;

/**
 *
 * @author Nicholas.Sixbury
 */
public class AppInterface extends javax.swing.JFrame {

    /**
     * Creates new form test
     */
    public AppInterface() {
        boolean darkMode = false;
        if(darkMode) {
            FlatDarkLaf.setup();
        }
        else {
            FlatLightLaf.setup();
        }
        
        initComponents();

        // update version and date and stuff
        jTextArea1.setText("\t\tFlight Mill Data File Compression Software " + ProcessDataLoggerFile.VERSION + "\n   \t> compresses 8 channel datafile collected from WinDaq hardware/software\n\n\t\t" + ProcessDataLoggerFile.PEOPLE + "  " + ProcessDataLoggerFile.DATE() + "\n\t\t" + ProcessDataLoggerFile.LOCATION);
        this.setTitle("USDA-ARS FMDFCS " + ProcessDataLoggerFile.VERSION);
        // load config stuff from file
        inputCommandLine = ProcessDataLoggerFile.loadInputCommandLine();
        updateConfigDisplay();
        // set up config dialog
        configDialog = new ConfigDialog(this, true);
        configDialog.parent_icl = inputCommandLine;
        // initialize uxStatusText
        uxStatusText.setText("Please select a file to process.");
        // set up date time dialog

    }//end constructor

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jScrollPane2 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        uxGetInputBtn = new javax.swing.JButton();
        uxGetOutputBtn = new javax.swing.JButton();
        uxGetInputTxt = new javax.swing.JTextField();
        uxGetOutputTxt = new javax.swing.JTextField();
        uxProcessBtn = new javax.swing.JButton();
        uxShowFileBtn = new javax.swing.JButton();
        jScrollPane1 = new javax.swing.JScrollPane();
        uxConfigDisplayText = new javax.swing.JTextArea();
        uxShowConfigBtn = new javax.swing.JButton();
        jScrollPane3 = new javax.swing.JScrollPane();
        uxStatusText = new javax.swing.JTextArea();
        uxGetCollectionTimeBtn = new javax.swing.JButton();
        uxGetCollectionTimeTxt = new javax.swing.JTextField();
        uxDirectoryTxt = new javax.swing.JTextField();
        uxDirectoryLbl = new javax.swing.JButton();
        uxConfirmCollectionTimeBtn = new javax.swing.JButton();
        uxConfirmCollectionTimeTxt = new javax.swing.JTextField();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jTextArea1.setEditable(false);
        jTextArea1.setColumns(20);
        jTextArea1.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        jTextArea1.setRows(5);
        jTextArea1.setText("\t\tFlight Mill Data File Compression Software v1.0.1\n   \t> compresses 8 channel datafile collected from WinDaq hardware/software\n\tNote: The entirety of this header is auto-generated within the constructor\n\t\tSixbury/Rust/Brabec  autogenerated\n\t\tUSDA-ARS   Manhattan, Kansas");
        jScrollPane2.setViewportView(jTextArea1);

        uxGetInputBtn.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        uxGetInputBtn.setText("Select Input File");
        uxGetInputBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                uxGetInputBtnActionPerformed(evt);
            }
        });

        uxGetOutputBtn.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        uxGetOutputBtn.setText("Output File");
        uxGetOutputBtn.setEnabled(false);
        uxGetOutputBtn.setOpaque(true);
        uxGetOutputBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                uxGetOutputBtnActionPerformed(evt);
            }
        });

        uxGetInputTxt.setEditable(false);
        uxGetInputTxt.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        uxGetInputTxt.setHorizontalAlignment(javax.swing.JTextField.LEFT);

        uxGetOutputTxt.setEditable(false);
        uxGetOutputTxt.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        uxGetOutputTxt.setHorizontalAlignment(javax.swing.JTextField.LEFT);

        uxProcessBtn.setFont(new java.awt.Font("Tahoma", 0, 18)); // NOI18N
        uxProcessBtn.setText("Process Sample");
        uxProcessBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                uxProcessBtnActionPerformed(evt);
            }
        });

        uxShowFileBtn.setText("Show Output Folder");
        uxShowFileBtn.setEnabled(false);
        uxShowFileBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                uxShowFileBtnActionPerformed(evt);
            }
        });

        uxConfigDisplayText.setEditable(false);
        uxConfigDisplayText.setColumns(20);
        uxConfigDisplayText.setFont(new java.awt.Font("Segoe UI", 0, 14)); // NOI18N
        uxConfigDisplayText.setRows(4);
        uxConfigDisplayText.setAutoscrolls(false);
        jScrollPane1.setViewportView(uxConfigDisplayText);

        uxShowConfigBtn.setFont(new java.awt.Font("Segoe UI", 0, 14)); // NOI18N
        uxShowConfigBtn.setText("Edit Config");
        uxShowConfigBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                uxShowConfigBtnActionPerformed(evt);
            }
        });

        uxStatusText.setEditable(false);
        uxStatusText.setColumns(20);
        uxStatusText.setFont(new java.awt.Font("Segoe UI", 0, 18)); // NOI18N
        uxStatusText.setRows(1);
        uxStatusText.setAutoscrolls(false);
        jScrollPane3.setViewportView(uxStatusText);

        uxGetCollectionTimeBtn.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        uxGetCollectionTimeBtn.setText("Select Collection Start Time");
        uxGetCollectionTimeBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                uxGetCollectionTimeBtnActionPerformed(evt);
            }
        });

        uxGetCollectionTimeTxt.setEditable(false);
        uxGetCollectionTimeTxt.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N

        uxDirectoryTxt.setEditable(false);
        uxDirectoryTxt.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        uxDirectoryTxt.setHorizontalAlignment(javax.swing.JTextField.TRAILING);

        uxDirectoryLbl.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        uxDirectoryLbl.setText("Directory");
        uxDirectoryLbl.setEnabled(false);
        uxDirectoryLbl.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                uxDirectoryLblActionPerformed(evt);
            }
        });

        uxConfirmCollectionTimeBtn.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        uxConfirmCollectionTimeBtn.setText("Confirm Collection Start Time");
        uxConfirmCollectionTimeBtn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                uxConfirmCollectionTimeBtnActionPerformed(evt);
            }
        });

        uxConfirmCollectionTimeTxt.setEditable(false);
        uxConfirmCollectionTimeTxt.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane2)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING, false)
                            .addComponent(uxDirectoryLbl, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(uxGetInputBtn, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .addComponent(uxGetOutputBtn, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(uxGetInputTxt)
                            .addComponent(uxGetOutputTxt)
                            .addComponent(uxDirectoryTxt)))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(uxGetCollectionTimeBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 240, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(uxGetCollectionTimeTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 391, javax.swing.GroupLayout.PREFERRED_SIZE))
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 446, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 446, javax.swing.GroupLayout.PREFERRED_SIZE))
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(uxProcessBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                                    .addComponent(uxShowFileBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 185, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addComponent(uxShowConfigBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 185, javax.swing.GroupLayout.PREFERRED_SIZE)))
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(uxConfirmCollectionTimeBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 240, javax.swing.GroupLayout.PREFERRED_SIZE)
                                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                .addComponent(uxConfirmCollectionTimeTxt, javax.swing.GroupLayout.PREFERRED_SIZE, 391, javax.swing.GroupLayout.PREFERRED_SIZE)))
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(18, 18, 18)
                .addComponent(jScrollPane2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(uxDirectoryLbl, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(uxDirectoryTxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addComponent(uxGetInputBtn, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(uxGetInputTxt))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(uxGetOutputBtn)
                    .addComponent(uxGetOutputTxt, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(uxGetCollectionTimeBtn)
                    .addComponent(uxGetCollectionTimeTxt))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(uxConfirmCollectionTimeBtn)
                    .addComponent(uxConfirmCollectionTimeTxt))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane3, javax.swing.GroupLayout.PREFERRED_SIZE, 49, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(uxProcessBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 46, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(uxShowFileBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(uxShowConfigBtn, javax.swing.GroupLayout.PREFERRED_SIZE, 32, javax.swing.GroupLayout.PREFERRED_SIZE))
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 70, javax.swing.GroupLayout.PREFERRED_SIZE)))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    protected File lastInputFile;
    public File getLastInputFile() {
        return lastInputFile;
    }//end getLastInputFile()
    protected File lastOutputFile;
    public File getLastOutputFile() {
        return lastOutputFile;
    }//end getLastOutputFile()

    /**
        File chooser for both opening and saving files
     */ 
    private JFileChooser fileChooser = new JFileChooser();
    private ActionListener actionListener = new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent e) {
            System.out.println(e.getActionCommand());
            if (e.getActionCommand() == "ApproveSelection") {
                lastInputFile = fileChooser.getSelectedFile();
                lastOutputFile = ProcessDataLoggerFile.reformatOutputFile(lastInputFile.getAbsolutePath(), false);
                uxDirectoryTxt.setText(lastInputFile.getParent());
                uxGetInputTxt.setText(lastInputFile.getName());
                uxGetOutputTxt.setText(lastOutputFile.getName());
                uxStatusText.setText("Click \"Process Sample\" button to get results.");
            }//end if selection was approved
            else if (e.getActionCommand() == "CancelSelection") {
                uxStatusText.setText("Please select a file and click confirm on the file dialog.");
            }//end else if user cancelled
        }//end actionPerformed
    };

    private void uxGetInputBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_uxGetInputBtnActionPerformed
        // clear from previous operations
        uxStatusText.setText("");
        uxShowFileBtn.setEnabled(false);
        // actually show the dialog
        fileChooser.addActionListener(actionListener);
        fileChooser.showOpenDialog(this);
        // // reset collection time
        // FileTime fileTime = ProcessDataLoggerFile.getFileCreationDate(new File(uxGetInputTxt.getText()));
        // dtDialog.dateTime = LocalDateTime.ofInstant(fileTime.toInstant(), ZoneId.systemDefault());
        // updateTimeDisplay();
    }//GEN-LAST:event_uxGetInputBtnActionPerformed

    private void uxGetOutputBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_uxGetOutputBtnActionPerformed
        fileChooser.addActionListener(new ActionListener() {
            @Override
            public void actionPerformed(ActionEvent e) {
                System.out.println(e.getActionCommand());
                lastOutputFile = fileChooser.getSelectedFile();
                uxGetOutputTxt.setText(lastOutputFile.getAbsolutePath());
            }
        } );
        fileChooser.showSaveDialog(this);
    }//GEN-LAST:event_uxGetOutputBtnActionPerformed

    public boolean isInputDataReady = false;
    public InputCommandLine inputCommandLine = new InputCommandLine();

    private void uxProcessBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_uxProcessBtnActionPerformed
        // check that there's actually a file to open
        String inputText = uxGetInputTxt.getText();
        if (inputText.isEmpty()) {
            // display message about empty file path
            JOptionPane.showMessageDialog(this, "You haven't selected a file to process." +
            "\nPlease click the \"Select Input File\" button to select a file.");
            return;
        }//end if input text isn't filled in
        if (uxGetCollectionTimeTxt.getText().isEmpty() || uxConfirmCollectionTimeTxt.getText().isEmpty()) {
            JOptionPane.showMessageDialog(this, "You haven't selected a time for both selections.\n" + 
            "Please select the time when the data was collected for both inputs.");
            return;
        }//end if collection time isn't filled in
        if (!uxGetCollectionTimeTxt.getText().equals(uxConfirmCollectionTimeTxt.getText())) {
            JOptionPane.showMessageDialog(this, "Collection times do not match.\n" +
            "Please select the same time for both collection time inputs.");
            return;
        }//end if collection times don't match

        // update status label
        uxStatusText.setText("Gathering Parameters");
        uxStatusText.paintImmediately(uxStatusText.getVisibleRect());

        inputCommandLine.inputFileName = lastInputFile.getAbsolutePath();
        inputCommandLine.outputFileName = lastOutputFile.getAbsolutePath();

        // just do all the processing, whatever
        try{
            
            if (inputCommandLine.zip_input_file) {
                // update status text
                uxStatusText.setText("Zipping Input File");
                uxStatusText.paintImmediately(uxStatusText.getVisibleRect());
                // actually zipping
                ProcessDataLoggerFile.zipFile(inputCommandLine.inputFileName);
            }
            if (inputCommandLine.inputFileName.endsWith(".zip")) {
                // update status text
                uxStatusText.setText("Unzipping Input File");
                uxStatusText.paintImmediately(uxStatusText.getVisibleRect());
                // actually unzipping
                String unzippedFileName = ProcessDataLoggerFile.unzipFile(inputCommandLine.inputFileName);
                inputCommandLine.inputFileName = unzippedFileName;
            }
    
            // test that input file isn't too big
            uxStatusText.setText("Testing size of input file");
            uxStatusText.paintImmediately(uxStatusText.getVisibleRect());
            boolean file_okay_to_run = ProcessDataLoggerFile.TestInputFileSize(inputCommandLine);
            // split file into multiple files if necessary without loading them in
            if (file_okay_to_run) {
                uxStatusText.setText("File seems okay");
                uxStatusText.paintImmediately(uxStatusText.getVisibleRect());
                doFileProcessing(inputCommandLine, 1, 1);
                JOptionPane.showMessageDialog(this, String.format("%d File has finished processing.", 1));
            }//end if we can have list of 1, no split required
            else {
                uxStatusText.setText("File size is too big. Splitting into multiple smaller files...");
                uxStatusText.paintImmediately(uxStatusText.getVisibleRect());
                List<InputCommandLine> files_to_process = ProcessDataLoggerFile.SplitInputFile(inputCommandLine);
                List<List<IntermediateDataLine>> all_peaks_channel_sorted = new ArrayList<List<IntermediateDataLine>>();
                double total_duration = 0;
                for (int i = 0; i < files_to_process.size(); i++) {
                    InputCommandLine this_icl = files_to_process.get(i);
                    // load file and get all lines
                    List<InputDataLine> this_input = doFileProcessingJustLoadInput(this_icl, i+1, files_to_process.size());
                    // get duration and add to running total
                    double this_duration = ProcessDataLoggerFile.getDuration(this_input);
                    total_duration += this_duration;
                    // get list of peaks, sorted by channel
                    List<List<IntermediateDataLine>> this_channel_sorted_peaks = doFileProcessingToSortedPeaks(this_input, this_icl, i+1, files_to_process.size());
                    // desperately try to save memory
                    this_input = null;
                    // for each channel, we want to fix any end and beginning values and add them to channelSortedPeaks
                    for (int j = 0; j < this_channel_sorted_peaks.size(); j++) {
                        // make sure all_peaks_channel_sorted is big enough to handle us
                        if (all_peaks_channel_sorted.size() < j + 1) {
                            List<IntermediateDataLine> new_channel_list = new ArrayList<IntermediateDataLine>();
                            all_peaks_channel_sorted.add(new_channel_list);
                        }//end if we need to increase size of all_peaks_channel_sorted to accomadate upcoming changes
                        // check first element of this_channel_sorted_peaks[j] with last element all_peaks_channel_sorted[j] if all_peaks_channel_sorted[j] not empty
                        if (all_peaks_channel_sorted.get(j).size() > 0 && this_channel_sorted_peaks.get(j).size() > 0) {
                            // Make sure first and last peaks are not screwed up
                            int all_peaks_last_index = all_peaks_channel_sorted.get(j).size() - 1;
                            IntermediateDataLine last_peak = all_peaks_channel_sorted.get(j).get(all_peaks_last_index);
                            IntermediateDataLine next_peak = this_channel_sorted_peaks.get(j).get(0);
                            if (last_peak.elapsedTime + last_peak.peakWidth * 0.004 >= next_peak.elapsedTime) {
                                // print out that we actually had this happen
                                System.out.println("It seems we actually have a split peak. Here are the details:");
                                System.out.println(String.format("last_peak started at time %d and ended at time %d.", last_peak.elapsedTime, last_peak.elapsedTime + (last_peak.peakWidth * 0.004)));
                                System.out.println(String.format("next_peak started at time %d.", next_peak.elapsedTime));
                                // Create merged data line from both peaks
                                IntermediateDataLine merged_peak = new IntermediateDataLine(last_peak.channel, last_peak.elapsedTime, last_peak.peakWidth + next_peak.peakWidth);
                                // replace last_peak in all_peaks_channel_sorted with merged_peak
                                all_peaks_channel_sorted.get(j).set(all_peaks_last_index, merged_peak);
                            }//end if it seems we have a split peak
                        }//end if we can go ahead and check elements
                        else {
                            if (this_channel_sorted_peaks.get(j).size() > 0) {
                                IntermediateDataLine this_peak = this_channel_sorted_peaks.get(j).get(0);
                                all_peaks_channel_sorted.get(j).add(this_peak);
                            }//end if we have a first element
                        }//end else add first element of this_channel_sorted_peaks[j] to all_peaks_channel_sorted[j] without alteration
                        // either way, from here, add each element in this_channel_sorted_peaks[j] to all_peaks_channel_sorted
                        for (int k = 1; k < this_channel_sorted_peaks.get(j).size(); k++) {
                            all_peaks_channel_sorted.get(j).add(this_channel_sorted_peaks.get(j).get(k));
                        }//end adding each element in this_channel_sorted_peaks[j] to all_peaks_channel_sorted[j] (except for first element)
                    }//end fixing beginning values of each channel and doing array maintenance
                }//end looping over each split file we made
                // do final direction processing and output of all our files together, using inputCommandLine for whole file and total duration earlier
                doFileProcessingDirectionOnwards(all_peaks_channel_sorted, total_duration, inputCommandLine, files_to_process.size(), files_to_process.size());
                JOptionPane.showMessageDialog(this, String.format("%d Files have finished processing.", files_to_process.size()));
            }//end else we need to split file and process each individually
            
            // clear collection time
            uxGetCollectionTimeTxt.setText("");
            uxConfirmCollectionTimeTxt.setText("");
        }//end trying to do whatever
        catch (FileNotFoundException ex) {
            uxStatusText.setText("File not found. Aborting...");
            uxStatusText.paintImmediately(uxStatusText.getVisibleRect());
            Logger.getLogger(ProcessDataLoggerFile.class.getName()).log(Level.SEVERE, 
                    null, ex);
        }//end catching FileNotFoundException
        catch (IOException ex) {
            uxStatusText.setText("An unspecified IO error has occured. Consider closing applications that might still be writing or reading from the file. Aborting...");
            uxStatusText.paintImmediately(uxStatusText.getVisibleRect());
            Logger.getLogger(ProcessDataLoggerFile.class.getName()).log(Level.SEVERE, 
                    null, ex);
        }//end catching IOExceptions
    }//GEN-LAST:event_uxProcessBtnActionPerformed

    private List<InputDataLine> doFileProcessingJustLoadInput(InputCommandLine icl, int curFileNum, int totFileNum) throws FileNotFoundException {
        // load the input file
        uxStatusText.setText(String.format("Loading input file %d of %d into memory.", curFileNum, totFileNum));
        uxStatusText.paintImmediately(uxStatusText.getVisibleRect());
        List<InputDataLine> inputList = ProcessDataLoggerFile.LoadInputFile(icl);
        return inputList;
    }//end doFileProcessingJustLoadInput()

    private List<List<IntermediateDataLine>> doFileProcessingToSortedPeaks(List<InputDataLine> inputList, InputCommandLine icl, int curFileNum, int totFileNum) {
        // make list of individual peaks
        uxStatusText.setText(String.format("Finding list of individual peaks for file %d of %d.", curFileNum, totFileNum));
        uxStatusText.paintImmediately(uxStatusText.getVisibleRect());
        List<IntermediateDataLine> processedInputList = ProcessDataLoggerFile.processInput(inputList,
                inputCommandLine);
        // sort peaks by channel
        uxStatusText.setText(String.format("Sorting peaks by channel to ease processing for file %d of %d.", curFileNum, totFileNum));
        uxStatusText.paintImmediately(uxStatusText.getVisibleRect());
        List<List<IntermediateDataLine>> channelSortedInputList = ProcessDataLoggerFile.separateIntermedDataByChannel(processedInputList);

        return channelSortedInputList;
    }//end doFileProcessingToSortedPeaks()

    private void doFileProcessingDirectionOnwards(List<List<IntermediateDataLine>> channel_sorted_peaks, double duration, InputCommandLine icl, int curFileNum, int totFileNum) throws FileNotFoundException {
        // figure out directionallity from those peaks
        uxStatusText.setText(String.format("Sifting through peaks to figure out directionallity for file %d of %d.", curFileNum, totFileNum));
        uxStatusText.paintImmediately(uxStatusText.getVisibleRect());
        List<FinalDataLine> directionedInputList = ProcessDataLoggerFile.processDirectionallity(channel_sorted_peaks, inputCommandLine);
        // write output file
        uxStatusText.setText(String.format("Writing the output for file %d of %d.", curFileNum, totFileNum));
        uxStatusText.paintImmediately(uxStatusText.getVisibleRect());
        ProcessDataLoggerFile.makeOutputFile(duration, directionedInputList, icl, dtDialog1.dateTime);
    }//end doFileProcessingDirectionOnwards()

    /**
     * Does the whole gui and processing stuff for one file. Extracted into a method for convenience with ux_ProcessBtnActionPerformed
     * @param icl THe inputCommandLine for the file in question
     * @param curFileNum
     * @param totFileNum
     * @throws FileNotFoundException 
     */
    private void doFileProcessing(InputCommandLine icl, int curFileNum, int totFileNum) throws FileNotFoundException {
        // user helper method to load file
        List<InputDataLine> inputList = doFileProcessingJustLoadInput(icl, curFileNum, totFileNum);
        double duration = ProcessDataLoggerFile.getDuration(inputList);
        // use helper method to get to point of sorted IntermediateDataLines
        List<List<IntermediateDataLine>> channelSortedInputList = doFileProcessingToSortedPeaks(inputList, icl, curFileNum, totFileNum);
        // do direction stuff and make the output file
        doFileProcessingDirectionOnwards(channelSortedInputList, duration, icl, curFileNum, totFileNum);
        // tell the user what happened
        uxStatusText.setText(String.format("File %d has finished processing.", curFileNum));
        uxStatusText.paintImmediately(uxStatusText.getVisibleRect());
        // enable "show in folder" button
        uxShowFileBtn.setEnabled(true);
    }//end doFileProcessing()

    private void uxShowFileBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_uxShowFileBtnActionPerformed
        // open the file in file explorer
        try {
            Runtime.getRuntime().exec("explorer.exe /select," + inputCommandLine.inputFileName);
        }//end trying to open file explorer
        catch(Exception e) {System.out.println("Couldn't open file explorer");}
    }//GEN-LAST:event_uxShowFileBtnActionPerformed

    ConfigDialog configDialog = new ConfigDialog(this, true);

    private void uxShowConfigBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_uxShowConfigBtnActionPerformed
        configDialog.updateConfig(inputCommandLine);
        configDialog.setVisible(true);
        updateConfigDisplay();
    }//GEN-LAST:event_uxShowConfigBtnActionPerformed

    DateTimeDialog dtDialog1 = new DateTimeDialog(this, true);
    DateTimeDialog dtDialog2 = new DateTimeDialog(this, true);
    DateTimeFormatter dtFormatter = DateTimeFormatter.ofPattern("MMM d, yyyy h:mm a");

    private void uxGetCollectionTimeBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_uxGetCollectionTimeBtnActionPerformed
        dtDialog1.updateDateTime();
        dtDialog1.setVisible(true);
        if (dtDialog1.is_input_valid) {
            updateTimeDisplay1();
        }//end if date time is valid
    }//GEN-LAST:event_uxGetCollectionTimeBtnActionPerformed
    
    private void uxConfirmCollectionTimeBtnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_uxConfirmCollectionTimeBtnActionPerformed
        dtDialog2.updateDateTime();
        dtDialog2.setVisible(true);
        if (dtDialog2.is_input_valid) {
            updateTimeDisplay2();
        }//end if date time is valid
    }//GEN-LAST:event_uxConfirmCollectionTimeBtnActionPerformed

    private void uxDirectoryLblActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_uxDirectoryLblActionPerformed
        // this doesn't do anything
    }//GEN-LAST:event_uxDirectoryLblActionPerformed

    private void updateTimeDisplay1() {
        uxGetCollectionTimeTxt.setText(dtDialog1.dateTime.format(dtFormatter));
    }//end updateTimeDisplay

    private void updateTimeDisplay2() {
        uxConfirmCollectionTimeTxt.setText(dtDialog2.dateTime.format(dtFormatter));
    }//end updateTimeDisplay

    private void updateConfigDisplay() {
        // update config display on main window
        StringBuilder sb = new StringBuilder();
        
        sb.append("Configuration File with current parameters:");
        for (String line : ProcessDataLoggerFile.getInputCommandLineStrings(inputCommandLine)) { sb.append("\n" + line); }

        // sb.append("No Date Time: " + inputCommandLine.dateTimeFlg);
        // sb.append("\tShow Peak Width: " + inputCommandLine.peakWidthFlg);
        // sb.append("\nZip File: " + inputCommandLine.zipFileFlg);
        // sb.append("\nLines to Skip: " + inputCommandLine.skipLines);
        // sb.append("\t\tThreshold for Peak: " + inputCommandLine.threshold);

        uxConfigDisplayText.setText(sb.toString());
        uxConfigDisplayText.setSelectionStart(0);
        uxConfigDisplayText.setSelectionEnd(0);

        // write changes to config file as well
        ProcessDataLoggerFile.saveInputCommandLine(inputCommandLine);
    }//end updateConfigDisplay()

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new AppInterface().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JScrollPane jScrollPane3;
    private javax.swing.JTextArea jTextArea1;
    private javax.swing.JTextArea uxConfigDisplayText;
    private javax.swing.JButton uxConfirmCollectionTimeBtn;
    private javax.swing.JTextField uxConfirmCollectionTimeTxt;
    private javax.swing.JButton uxDirectoryLbl;
    private javax.swing.JTextField uxDirectoryTxt;
    private javax.swing.JButton uxGetCollectionTimeBtn;
    private javax.swing.JTextField uxGetCollectionTimeTxt;
    private javax.swing.JButton uxGetInputBtn;
    private javax.swing.JTextField uxGetInputTxt;
    private javax.swing.JButton uxGetOutputBtn;
    private javax.swing.JTextField uxGetOutputTxt;
    private javax.swing.JButton uxProcessBtn;
    private javax.swing.JButton uxShowConfigBtn;
    private javax.swing.JButton uxShowFileBtn;
    private javax.swing.JTextArea uxStatusText;
    // End of variables declaration//GEN-END:variables
}
